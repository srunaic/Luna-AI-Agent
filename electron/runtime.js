const http = require('http');
const https = require('https');

class AgentRuntime {
    constructor() { this.isRunning = false; }
    async processRequest(request, onResponse) {
        if (this.isRunning) return;
        this.isRunning = true;
        const { instruction, context } = request;
        const model = context.model || 'ollama';
        try {
            const isComplexTask = instruction.includes('???') || instruction.includes('???') || instruction.includes('?????) || instruction.includes('???') || instruction.length > 100;
            if (!isComplexTask) {
                onResponse({ type: 'status', data: { state: 'thinking', message: '', isPartial: true, taskId: context.taskId } });
                let fullText = await this.callLunaCore(instruction, context, onResponse, true);
                onResponse({ type: 'done', data: { success: true, message: fullText, taskId: context.taskId } });
                return;
            }
            let turn = 0; let history = [];
            while (turn < 5) {
                turn++;
                onResponse({ type: 'status', data: { state: 'thinking', message: ?? ????? ??? ??????... (Turn \), taskId: context.taskId } });
                let responseText = await this.callLunaCore(instruction, { ...context, history }, onResponse);
                const toolMatch = responseText.match(/TOOL:\s*(\w+)\s*\nINPUT:\s*([\s\S]+?)(?=\n(?:THOUGHT|TOOL|ANSWER):|$)/i);
                const answerMatch = responseText.match(/ANSWER:\s*([\s\S]+)/i);
                if (toolMatch) {
                    const toolName = toolMatch[1].trim();
                    const toolInput = toolMatch[2].trim().replace(/^`\w*\n?/, '').replace(/\n?`$/, '');
                    onResponse({ type: 'status', data: { state: 'executing', message: ?? \ ???????? ??????..., taskId: context.taskId } });
                    let toolResult = await this.executeTool(toolName, toolInput, context);
                    onResponse({ type: 'action', data: { tool: toolName, input: toolInput, result: toolResult, taskId: context.taskId } });
                    history.push({ role: 'assistant', content: responseText });
                    history.push({ role: 'system', content: TOOL_RESULT: \ });
                    continue;
                }
                if (answerMatch || responseText) {
                    onResponse({ type: 'done', data: { success: true, message: answerMatch ? answerMatch[1].trim() : responseText, taskId: context.taskId } });
                    break;
                }
            }
        } finally { this.isRunning = false; }
    }
    async callLunaCore(instruction, context, onResponse, directMode = false) {
        const prompt = directMode ? instruction : this.buildPrompt(instruction, context);
        return new Promise((resolve, reject) => {
            const cfg = context.llmSettings?.ollama || {};
            const modelNameBase = context.model === 'luna-soul' ? 'luna-soul' : String(cfg.model || 'luna-soul');
            let modelName = modelNameBase.includes(':') ? modelNameBase : \:latest\;
            const payload = { model: modelName, prompt: prompt, stream: true, options: { num_ctx: 2048, temperature: 0.1 }, keep_alive: "60m" };
            const req = http.request({ hostname: '127.0.0.1', port: 11434, path: '/api/generate', method: 'POST' }, (res) => {
                let fullText = ""; let buffer = ""; let firstToken = true;
                res.on('data', (chunk) => {
                    buffer += chunk.toString();
                    let boundary = buffer.indexOf('}');
                    while (boundary !== -1) {
                        const jsonStr = buffer.substring(0, boundary + 1);
                        buffer = buffer.substring(boundary + 1);
                        try {
                            const json = JSON.parse(jsonStr);
                            if (firstToken && json.response) { onResponse({ type: 'status', data: { state: 'typing', message: '', isPartial: true, taskId: context.taskId } }); firstToken = false; }
                            if (json.response) { fullText += json.response; onResponse({ type: 'status', data: { state: 'typing', message: fullText, isPartial: true, taskId: context.taskId } }); }
                            if (json.done) resolve(fullText);
                        } catch (e) {}
                        boundary = buffer.indexOf('}');
                    }
                });
            });
            req.write(JSON.stringify(payload)); req.end();
        });
    }
    buildPrompt(instruction, context) {
        return \????? Luna Soul, ?????? ??????????? ???????? ??????????? AI ???????????
????? ????????????? ????? ????? ??????????? IT ??? ????? ??????????????? ?????? ??????????

[??????????& ?????????
1. ?????? ????????: ??? ???(THOUGHT)?? ???(ANSWER)?? 100% ?????? ?????????. 
   - '??', '???!', '????????? ???', '???????????'?? ??? ???????IT ?????? ??? ???????????????? ???????? ?????????.
   - ???/??? ???(?? '???', '???', '???')????? ?????????????? ????????
2. ??????????(UTF-8): ??? ??? ???(write_file)?? ?????UTF-8(BOM ???) ???????????????
3. ??? ???: ?????? ???(TOOL) ????????????? 
4. VS Code ???: ????? ??? VS Code ?????Monaco Editor ??? ???????? ??????.

[????????]

[??? ????? ???]
1. list_dir, read_file, write_file, terminal_run, open_url, open_app, deep_learn

[??? ????????]
THOUGHT: (??? ??? ???. ???????? ???.)
TOOL: ???_???
INPUT: ???_???
ANSWER: (??? ??? - ?????? ?????? ???????????. "?? ???????????" ??????????)\;
    }
    async executeTool(name, input, context) {
        const fs = require('fs'); const path = require('path');
        const root = context.projectRoot || process.cwd();
        if (name === 'write_file') {
            const idx = input.indexOf('\n');
            fs.writeFileSync(path.resolve(root, input.substring(0, idx).trim()), input.substring(idx+1), 'utf8');
            return "??? ??? ???";
        }
        return "??? ??? ???";
    }
}
module.exports = { AgentRuntime };